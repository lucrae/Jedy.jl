var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Documentation of Jedy's functions/types/etc.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Contents:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Jedy comprises the base/key functionality.\nJedy.EvolutionaryProcesses comprises helpful functions for evolutionary processes (e.g. imitation, mutation, Wright-Fisher processes).","category":"page"},{"location":"api/#base","page":"API","title":"Jedy","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Jedy]","category":"page"},{"location":"api/#Jedy.Agent","page":"API","title":"Jedy.Agent","text":"Agent(body[, body_hidden])\n\nBasic struct for a single agent.\n\nFields\n\nbody::Union{Dict, Array} – A Dict or Array data structure of attributes of the agent able to be involved in an evolutionary process.\n(Optional) body_hidden::Union{Dict, Array} – A Dict or Array data structure of attributes that will not be mutated/imitated/involved if the agent is used in an evolutionary process.\n\nExamples\n\nusing Jedy\n\n# An agent with a simple body of normal attributes.\nsimple_agent = Jedy.Agent(Dict(\"behaviour\" => 3))\n\n# An agent with some normal (sharable) attributes and some hidden attributes.\ncomplex_agent = Jedy.Agent(\n    Dict(\"behaviour\" => 3, \"colour\" => 2),\n    body_hidden=Dict(\"reputation\") => 1\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#Jedy.run_simulation!","page":"API","title":"Jedy.run_simulation!","text":"run_simulation!(agents, fitnesses_computer, evolutionary_process!, n_epochs)\n\nRuns a simulation.\n\nnote: Note\nThis is in-place for memory conservation, so the original agents array is mutated. Deep copy if there is a reason to preserve the original.\n\nInput\n\nagents::Array{Agent} – An array of Agent objects.\nfitness_computer::Function – A function that takes in an Array{Agent} and returns an Array{Float64} of the same length.\nevolutionary_process!::Function – An in-place function that takes in an Array{Agent} and Array{Float64} of the same length and performs an evolutionary process on the Array{Agent}. \nn_epcohs::Int – The number of epochs (iterations) to run on the agents.\n(Optional) logger::Function – A function that takes in an Array{Agent} and returns a Tuple{String, Array} of a csv/log/txt file name and 1D-array of values to be written each epoch. Warning: currently slightly performance-heavy.\n\n\n\n\n\n","category":"function"},{"location":"api/#evolutionary-processes","page":"API","title":"Jedy.EvolutionaryProcesses","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Jedy.EvolutionProcesses]","category":"page"},{"location":"api/#Jedy.EvolutionProcesses.create_imitation_process-Tuple","page":"API","title":"Jedy.EvolutionProcesses.create_imitation_process","text":"create_imitation_process(w)\n\nShorthand to create an imitation process function. See Jedy.EvolutionProcesses.imitation_process!.\n\nInput\n\nw::Float64 – The intensity of selection (between 0 and 1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Jedy.EvolutionProcesses.create_moran_process-Tuple","page":"API","title":"Jedy.EvolutionProcesses.create_moran_process","text":"create_moran_process(w)\n\nShorthand to create a moran process function. See Jedy.EvolutionProcesses.moran_process!.\n\nInput\n\nw::Float64 – The intensity of selection (between 0 and 1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Jedy.EvolutionProcesses.imitation_process!-Tuple{Array{Jedy.Agent, N} where N, Array{Float64, N} where N, Float64}","page":"API","title":"Jedy.EvolutionProcesses.imitation_process!","text":"imitation_process!(agents, fitnesses, w)\n\nPerforms an (in-place) imitation process on some agents and their fitnesses with a given w intensity of selection.\n\nInput\n\nagents::Array{Jedy.Agent} – An array of Agent objects.\nfitnesses::Array{Float64} – An array of floats corresponding to each agent.\nw::Float64 – The intensity of selection (between 0 and 1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Jedy.EvolutionProcesses.moran_process!-Tuple{Array{Jedy.Agent, N} where N, Array{Float64, N} where N, Float64}","page":"API","title":"Jedy.EvolutionProcesses.moran_process!","text":"moran_process!(agents, fitnesses, w)\n\nPerforms an (in-place) moran process on some agents and their fitnesses with a given w intensity of selection.\n\nInput\n\nagents::Array{Jedy.Agent} – An array of Agent objects.\nfitnesses::Array{Float64} – An array of floats corresponding to each agent.\nw::Float64 – The intensity of selection (between 0 and 1).\n\n\n\n\n\n","category":"method"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"warning: Warning\nUnder construction...","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"warning: Warning\nUnder construction...","category":"page"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/#Scientific-computing-and-Julia","page":"Introduction","title":"Scientific computing and Julia","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The compromises between low-level and high-level programming languages presents a challenge for scientific computing.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Relatively lower-level languages (by modern stanards) such as C/C++ provide highly efficient performance, but because their design is oriented towards systems programming they have a strong specificity for low-level or “machine-oriented” operations such as memory allocation that bloats development time and makes them very unsuitable for fast or intuitive prototyping—an attribute very important for scientific computing.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Higher-level languages such as Python have consequently become popular in many areas of modern scientific computing due to a “friendlier” approach to readability and automation of low-level operations, but the implementation of being easy and dynamic, mainly through being interpreted—rather than compiled—also produces far less optimal performance. Especially in computing tasks that rely on optimised, repeated operations, such as simulations, the slowness of Python and other popular high-level languages produces magnitudes of inefficiency.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"First appearing in 2012–relatively recent for a programming language–the Julia programming language has emerged as a solution to this rift between ease and performance, providing the high-level dynamic readability of Python, but through sophisticated design decisions such as a just-in-time (JIT) compiler and eager evaluation, it delivers on the optimised performance seen by the likes of C/C++, achieving petaFLOP computations. Julia, as a result, presents new and exciting potential for new works in scientific computing.","category":"page"},{"location":"introduction/#Agent-based-simulations","page":"Introduction","title":"Agent-based simulations","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Agent-based simulations are a highly important computational task in game theory. Setting up theoretical agent-based models, these simulations play out the actions and interactions of autonomous agents in theoretical situations to prove or disprove hypotheses or reveal new insights into problems of social conflict, dilemmas, and cooperation.","category":"page"},{"location":"introduction/#The-Jedy-package","page":"Introduction","title":"The Jedy package","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Jedy (name originating from from Julia Evolutionary DYnamics) is a package for Julia that provides useful building blocks to run agent-based simuations. The primary focus is to provide abstractions that allow for quick, intuitive, and reliable development of agent-based ideas, and already implemented and tested functions to run commonly-used evolutionary algorithms such as imitation processes and Wright-Fisher evolution.","category":"page"},{"location":"introduction/#Development","page":"Introduction","title":"Development","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Jedy has been developed by Lucien Rae Gentil with the supervision and expertise of Julian Garcia. The source code is open-source and available here, open to contributions, alongside thorough documentation.","category":"page"},{"location":"#Jedy.jl","page":"Home","title":"Jedy.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for developing agent-based simulations & evolutionary dynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jedy provides fundamental tooling to work with agents and evolutionary algorithms, making use of Julia's speed and ease-of-development. See Introduction for an in-depth explanation to Jedy's motivation and approach.","category":"page"},{"location":"#Working-with-Jedy","page":"Home","title":"Working with Jedy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See Getting Started for easy instructions to installing/using Jedy.\nSee API for documentation on Jedy's functions/types/etc.\nSee Examples for examples of using Jedy.","category":"page"}]
}
