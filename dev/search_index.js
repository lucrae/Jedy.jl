var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Documentation of Jedy's functions/types/etc.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Contents:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Jedy comprises the base/key functionality.\nJedy.EvolutionaryProcesses comprises helpful functions for evolutionary processes (e.g. imitation, mutation, Wright-Fisher processes).","category":"page"},{"location":"api/#base","page":"API","title":"Jedy","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Jedy]","category":"page"},{"location":"api/#Jedy.Agent","page":"API","title":"Jedy.Agent","text":"Agent(body[, body_hidden])\n\nBasic struct for a single agent.\n\nFields\n\nbody::Union{Dict, Array} – A Dict or Array data structure of attributes of the agent able to be involved in an evolutionary process.\n(Optional) body_hidden::Union{Dict, Array} – A Dict or Array data structure of attributes that will not be mutated/imitated/involved if the agent is used in an evolutionary process.\n\nExamples\n\nusing Jedy\n\n# An agent with a simple body of normal attributes.\nsimple_agent = Jedy.Agent(Dict(\"behaviour\" => 3))\n\n# An agent with some normal (sharable) attributes and some hidden attributes.\ncomplex_agent = Jedy.Agent(\n    Dict(\"behaviour\" => 3, \"colour\" => 2),\n    body_hidden=Dict(\"reputation\") => 1\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#Jedy.run_simulation!","page":"API","title":"Jedy.run_simulation!","text":"run_simulation!(agents, fitnesses_computer, evolutionary_process!, n_epochs)\n\nRuns a simulation.\n\nnote: Note\nThis is in-place for memory conservation, so the original agents array is mutated. Deep copy if there is a reason to preserve the original.\n\nInput\n\nagents::Array{Agent} – An array of Agent objects.\nfitness_computer::Function – A function that takes in an Array{Agent} and returns an Array{Float64} of the same length.\nevolutionary_process!::Function – An in-place function that takes in an Array{Agent} and Array{Float64} of the same length and performs an evolutionary process on the Array{Agent}. \nn_epcohs::Int – The number of epochs (iterations) to run on the agents.\n(Optional) logger::Function – A function that takes in an Array{Agent} and returns a Tuple{String, Array} of a csv/log/txt file name and 1D-array of values to be written each epoch. Warning: currently slightly performance-heavy.\n\n\n\n\n\n","category":"function"},{"location":"api/#evolutionary-processes","page":"API","title":"Jedy.EvolutionaryProcesses","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Jedy.EvolutionProcesses]","category":"page"},{"location":"api/#Jedy.EvolutionProcesses.create_imitation_process-Tuple","page":"API","title":"Jedy.EvolutionProcesses.create_imitation_process","text":"create_imitation_process(w)\n\nShorthand to create an imitation process function. See Jedy.EvolutionProcesses.imitation_process!.\n\nInput\n\nw::Float64 – The intensity of selection (between 0 and 1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Jedy.EvolutionProcesses.create_moran_process-Tuple","page":"API","title":"Jedy.EvolutionProcesses.create_moran_process","text":"create_moran_process(w)\n\nShorthand to create a moran process function. See Jedy.EvolutionProcesses.moran_process!.\n\nInput\n\nw::Float64 – The intensity of selection (between 0 and 1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Jedy.EvolutionProcesses.imitation_process!-Tuple{Array{Jedy.Agent, N} where N, Array{Float64, N} where N, Float64}","page":"API","title":"Jedy.EvolutionProcesses.imitation_process!","text":"imitation_process!(agents, fitnesses, w)\n\nPerforms an (in-place) imitation process on some agents and their fitnesses with a given w intensity of selection.\n\nInput\n\nagents::Array{Jedy.Agent} – An array of Agent objects.\nfitnesses::Array{Float64} – An array of floats corresponding to each agent.\nw::Float64 – The intensity of selection (between 0 and 1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Jedy.EvolutionProcesses.moran_process!-Tuple{Array{Jedy.Agent, N} where N, Array{Float64, N} where N, Float64}","page":"API","title":"Jedy.EvolutionProcesses.moran_process!","text":"moran_process!(agents, fitnesses, w)\n\nPerforms an (in-place) moran process on some agents and their fitnesses with a given w intensity of selection.\n\nInput\n\nagents::Array{Jedy.Agent} – An array of Agent objects.\nfitnesses::Array{Float64} – An array of floats corresponding to each agent.\nw::Float64 – The intensity of selection (between 0 and 1).\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Full code can be found on GitHub.","category":"page"},{"location":"examples/#The-Prisoner's-Dilemma","page":"Examples","title":"The Prisoner's Dilemma","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can use Jedy to simulate agents playing the repeated Prisoner's Dilemma and an evolutionary process to see the success of defecting vs. cooperating.","category":"page"},{"location":"examples/#.-Define-population","page":"Examples","title":"1. Define population","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, let's make a population of 100 agents with a randomly-assigned boolean attribute \"behaviour\" that defines if they defect (true) or cooperate (false):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import Jedy\nimport Random\n\nN = 100\nagents = Array{Jedy.Agent}(undef, N)\nfor i in 1:N\n    agents[i] = Jedy.Agent(Dict(\"behaviour\" => rand(Bool)))\nend","category":"page"},{"location":"examples/#.-Define-way-of-determining-payoffs/fitness","page":"Examples","title":"2. Define way of determining payoffs/fitness","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We use a straight-forward function for two agents to play the Prisoner's Dilemma:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function play_prisoners_dilemma(agent_a::Jedy.Agent, agent_b::Jedy.Agent) :: Tuple{Int, Int}\n    T, R, P, S = 3, 2, 1, 0\n    action_a = agent_a.body[\"behaviour\"]\n    action_b = agent_b.body[\"behaviour\"]\n    if action_a && action_b\n        return (P, P)\n    elseif action_a && !action_b\n        return (T, S)\n    elseif !action_a && action_b\n        return (S, T)\n    else\n        return (R, R)\n    end\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can then use this for our compute_fitness function. Here we compute fitness by the total payoff each agent accumulates against 1000 random opponents.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function compute_fitnesses(agents::Array{Jedy.Agent}) :: Array{Float64}\n    n = length(agents)\n    fitnesses = zeros(n)\n\n    for f in 1:n\n        for _ in 1:100 # Agent[f] plays 100 prisoner's dilemmas\n            r = f\n            while r == f # Pick non-self opponent\n                r = rand(1:n)\n            end\n            payoff_f, payoff_r = play_prisoners_dilemma(agents[f], agents[r])\n            fitnesses[f] += payoff_f\n            fitnesses[r] += payoff_r\n        end\n    end\n    return fitnesses\nend","category":"page"},{"location":"examples/#.-Define-evolution-process","page":"Examples","title":"3. Define evolution process","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's use an imitation process.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Imitation process with w=0.2 (weak selection)\nimitation_process! = Jedy.EvolutionProcesses.create_imitation_process(0.2)","category":"page"},{"location":"examples/#.-Run-simulation!","page":"Examples","title":"4. Run simulation!","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we do 200 epochs:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Jedy.run_simulation!(agents,\n                     compute_fitnesses,\n                     imitation_process!,\n                     200)","category":"page"},{"location":"examples/#(Optional)-Logging-to-CSV","page":"Examples","title":"(Optional) Logging to CSV","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"It's very useful to be able to log values from each epoch's agents. We can add a highly-customisable logger function easily:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Logs the behaviour of each agent\nfunction logger(agents::Array{Jedy.Agent})\n    vals = map(a -> a.body[\"behaviour\"], agents)\n    return \"temp.log\", vals\nend\n\n# Run simulation with logger\nJedy.run_simulation!(agents,\n                     compute_fitnesses,\n                     perform_imitation_process!,\n                     200,\n                     logger)","category":"page"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/#Agent-based-simulations","page":"Introduction","title":"Agent-based simulations","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Agent-based simulations are a highly important scientific computing task in game theory. Setting up theoretical agent-based models, these simulations play out the actions and interactions of autonomous agents in theoretical situations to prove or disprove hypotheses or reveal new insights into problems of social conflict, dilemmas, and cooperation.","category":"page"},{"location":"introduction/#Scientific-computing-and-Julia","page":"Introduction","title":"Scientific computing and Julia","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The compromises between low-level and high-level programming languages presents a challenge for scientific computing.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Relatively lower-level languages (by modern stanards) such as C/C++ provide highly efficient performance, but because their design is oriented towards systems programming they have a strong specificity for low-level or “machine-oriented” operations such as memory allocation that bloats development time and makes them very unsuitable for fast or intuitive prototyping—an attribute very important for scientific computing.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Higher-level languages such as Python have consequently become popular in many areas of modern scientific computing due to a “friendlier” approach to readability and automation of low-level operations, but the implementation of being easy and dynamic, mainly through being interpreted—rather than compiled—also produces far less optimal performance. Especially in computing tasks that rely on optimised, repeated operations, such as simulations, the slowness of Python and other popular high-level languages produces magnitudes of inefficiency.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"First appearing in 2012–relatively recent for a programming language–the Julia programming language has emerged as a solution to this rift between ease and performance, providing the high-level dynamic readability of Python, but through sophisticated design decisions such as a just-in-time (JIT) compiler and eager evaluation, it delivers on the optimised performance seen by the likes of C/C++, achieving petaFLOP computations. Julia, as a result, presents new and exciting potential for new works in scientific computing.","category":"page"},{"location":"introduction/#The-Jedy-package","page":"Introduction","title":"The Jedy package","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Jedy (name originating from from Julia Evolutionary DYnamics) is a package for Julia that provides useful building blocks to run agent-based simuations. The primary focus is to provide abstractions that allow for quick, intuitive, and reliable development of agent-based ideas, and already implemented and tested functions to run commonly-used evolutionary algorithms such as imitation processes and Wright-Fisher evolution.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Jedy has been developed by Lucien Rae Gentil with the supervision and expertise of Julian Garcia. The source code is open-source and available here, open to contributions, alongside thorough documentation.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"For in-depth examples and complete documentation of Jedy's API:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"See Examples for examples of using Jedy.\nSee API for complete documentation on Jedy's functions/types/etc.","category":"page"},{"location":"introduction/#References-and-Resources","page":"Introduction","title":"References and Resources","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Hindersin, L., Wu, B., Traulsen, A., &#38; García, J. (2019). Computation and Simulation of Evolutionary Game Dynamics in Finite Populations. Scientific Reports, 9(1). Open Access.\nTraulsen, A., &#38; Hauert, C. (2009). Stochastic evolutionary game dynamics. Reviews of Nonlinear Dynamics and Complexity, 2, 25–61. PDF.\nXu, J., Garcia, J., &#38; Handfield, T. (2019). Cooperation with bottom-up reputation dynamics. Proceedings of the 18th International Conference on Autonomous Agents and MultiAgent Systems, 269–276. PDF.","category":"page"},{"location":"#Jedy.jl","page":"Home","title":"Jedy.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for developing agent-based simulations & evolutionary dynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jedy provides fundamental tooling to work with agents and evolutionary algorithms, making use of Julia's speed and ease-of-development.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Open the Julia REPL in your terminal with julia, type ] to enter the Pkg mode, and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/lucrae/Jedy.jl.git","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simply import Jedy and use the functions/types in the API. For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Jedy\n\na = Jedy.Agent(\"behaviour\" => 1)","category":"page"},{"location":"#Resources","page":"Home","title":"Resources","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See Introduction for an in-depth explanation to Jedy's motivation and approach. \nSee Examples for examples of using Jedy.\nSee API for complete documentation on Jedy's functions/types/etc.","category":"page"}]
}
