var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Documentation of Jedy's functions/types/etc.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Contents:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Jedy comprises the base/key functionality.\nJedy.EvolutionaryProcesses comprises helpful functions for evolutionary processes (e.g. imitation, mutation, Wright-Fisher processes).","category":"page"},{"location":"api/#base","page":"API","title":"Jedy","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Jedy]","category":"page"},{"location":"api/#Jedy.Agent","page":"API","title":"Jedy.Agent","text":"Agent(body[, body_hidden])\n\nBasic struct for a single agent.\n\nFields\n\nbody::Union{Dict, Array} – A Dict or Array data structure of attributes of the agent able to be involved in an evolutionary process.\n(Optional) body_hidden::Union{Dict, Array} – A Dict or Array data structure of attributes that will not be mutated/imitated/involved if the agent is used in an evolutionary process.\n\nExamples\n\nusing Jedy\n\n# An agent with a simple body of normal attributes.\nsimple_agent = Jedy.Agent(Dict(\"behaviour\" => 3))\n\n# An agent with some normal (sharable) attributes and some hidden attributes.\ncomplex_agent = Jedy.Agent(\n    Dict(\"behaviour\" => 3, \"colour\" => 2),\n    body_hidden=Dict(\"reputation\") => 1\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#Jedy.run_simulation!","page":"API","title":"Jedy.run_simulation!","text":"run_simulation!(agents, fitnesses_computer, evolutionary_process!, n_epochs)\n\nRuns a simulation.\n\nnote: Note\nThis is in-place for memory conservation, so the original agents array is mutated. Deep copy if there is a reason to preserve the original.\n\nInput\n\nagents::Array{Agent} – An array of Agent objects.\nfitness_computer::Function – A function that takes in an Array{Agent} and returns an Array{Float64} of the same length.\nevolutionary_process!::Function – An in-place function that takes in an Array{Agent} and Array{Float64} of the same length and performs an evolutionary process on the Array{Agent}. \nn_epcohs::Int – The number of epochs (iterations) to run on the agents.\n(Optional) logger::Function – A function that takes in an Array{Agent} and returns a Tuple{String, Array} of a csv/log/txt file name and 1D-array of values to be written each epoch. Warning: currently slightly performance-heavy.\n\n\n\n\n\n","category":"function"},{"location":"api/#evolutionary-processes","page":"API","title":"Jedy.EvolutionaryProcesses","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Jedy.EvolutionProcesses]","category":"page"},{"location":"api/#Jedy.EvolutionProcesses.create_imitation_process-Tuple","page":"API","title":"Jedy.EvolutionProcesses.create_imitation_process","text":"create_imitation_process(w)\n\nShorthand to create an imitation process function. See Jedy.EvolutionProcesses.imitation_process!.\n\nInput\n\nw::Float64 – The intensity of selection (between 0 and 1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Jedy.EvolutionProcesses.create_moran_process-Tuple","page":"API","title":"Jedy.EvolutionProcesses.create_moran_process","text":"create_moran_process(w)\n\nShorthand to create a moran process function. See Jedy.EvolutionProcesses.moran_process!.\n\nInput\n\nw::Float64 – The intensity of selection (between 0 and 1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Jedy.EvolutionProcesses.imitation_process!-Tuple{Array{Jedy.Agent, N} where N, Array{Float64, N} where N, Float64}","page":"API","title":"Jedy.EvolutionProcesses.imitation_process!","text":"imitation_process!(agents, fitnesses, w)\n\nPerforms an (in-place) imitation process on some agents and their fitnesses with a given w intensity of selection.\n\nInput\n\nagents::Array{Jedy.Agent} – An array of Agent objects.\nfitnesses::Array{Float64} – An array of floats corresponding to each agent.\nw::Float64 – The intensity of selection (between 0 and 1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Jedy.EvolutionProcesses.moran_process!-Tuple{Array{Jedy.Agent, N} where N, Array{Float64, N} where N, Float64}","page":"API","title":"Jedy.EvolutionProcesses.moran_process!","text":"moran_process!(agents, fitnesses, w)\n\nPerforms an (in-place) moran process on some agents and their fitnesses with a given w intensity of selection.\n\nInput\n\nagents::Array{Jedy.Agent} – An array of Agent objects.\nfitnesses::Array{Float64} – An array of floats corresponding to each agent.\nw::Float64 – The intensity of selection (between 0 and 1).\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Full code can be found on GitHub.","category":"page"},{"location":"examples/#The-Prisoner's-Dilemma","page":"Examples","title":"The Prisoner's Dilemma","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The Prisoner's Dilemma is a staple problem in game theory. Two agents must choose to either defect or cooperate with the other, without knowing the others' choice, where defecting when the other cooperates provides the highest reward T and lowest S to the other, but both defecting provides a low reward P, and both cooperating provides a decent reward R such that T > R > P > S. The key insight from analysing behaviour in the prisoner's dilemma is that agents will tend to defect instead of cooperate as the Nash Equilibrium, even though this will result in an overall worse payoff in the end than cooperation. This is of fundamental interest to the study of how unoptimal consequences of cooperation/defection in the real world can occur.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can use Jedy to simulate agents playing the repeated Prisoner's Dilemma with an evolutionary process to see the success of defecting vs. cooperating.","category":"page"},{"location":"examples/#.-Define-population","page":"Examples","title":"1. Define population","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, let's make a population of 100 agents with a randomly-assigned boolean attribute \"behaviour\" that defines if they defect (true) or cooperate (false):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import Jedy\nimport Random\n\nN = 100\nagents = Array{Jedy.Agent}(undef, N)\nfor i in 1:N\n    agents[i] = Jedy.Agent(Dict(\"behaviour\" => rand(Bool)))\nend","category":"page"},{"location":"examples/#.-Define-way-of-determining-payoffs/fitness","page":"Examples","title":"2. Define way of determining payoffs/fitness","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We use a straight-forward function for two agents to play the Prisoner's Dilemma:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function play_prisoners_dilemma(agent_a::Jedy.Agent, agent_b::Jedy.Agent) :: Tuple{Int, Int}\n    T, R, P, S = 3, 2, 1, 0\n    action_a = agent_a.body[\"behaviour\"]\n    action_b = agent_b.body[\"behaviour\"]\n    if action_a && action_b\n        return (P, P)\n    elseif action_a && !action_b\n        return (T, S)\n    elseif !action_a && action_b\n        return (S, T)\n    else\n        return (R, R)\n    end\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can then use this for our compute_fitness function. Here we compute fitness by the total payoff each agent accumulates against 1000 random opponents.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function compute_fitnesses(agents::Array{Jedy.Agent}) :: Array{Float64}\n    n = length(agents)\n    fitnesses = zeros(n)\n\n    for f in 1:n\n        for _ in 1:100 # Agent[f] plays 100 prisoner's dilemmas\n            r = f\n            while r == f # Pick non-self opponent\n                r = rand(1:n)\n            end\n            payoff_f, payoff_r = play_prisoners_dilemma(agents[f], agents[r])\n            fitnesses[f] += payoff_f\n            fitnesses[r] += payoff_r\n        end\n    end\n    return fitnesses\nend","category":"page"},{"location":"examples/#.-Define-evolution-process","page":"Examples","title":"3. Define evolution process","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's use an imitation process.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Imitation process with w=0.2 (weak selection)\nimitation_process! = Jedy.EvolutionProcesses.create_imitation_process(0.2)","category":"page"},{"location":"examples/#.-Run-simulation!","page":"Examples","title":"4. Run simulation!","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we do 200 epochs:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Jedy.run_simulation!(agents,\n                     compute_fitnesses,\n                     imitation_process!,\n                     200)","category":"page"},{"location":"examples/#(Optional)-Logging-to-CSV","page":"Examples","title":"(Optional) Logging to CSV","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"It's very useful to be able to log values from each epoch's agents. We can add a highly-customisable logger function easily:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Logs the behaviour of each agent\nfunction logger(agents::Array{Jedy.Agent})\n    vals = map(a -> a.body[\"behaviour\"], agents)\n    return \"temp.log\", vals\nend\n\n# Run simulation with logger\nJedy.run_simulation!(agents,\n                     compute_fitnesses,\n                     perform_imitation_process!,\n                     200,\n                     logger)","category":"page"},{"location":"introduction/#introduction","page":"Introduction","title":"Background","text":"","category":"section"},{"location":"introduction/#Game-theory","page":"Introduction","title":"Game theory","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The field of game theory studies the strategic interactions between agents, most commonly analysing behaviour in models that result from certain actions and payoffs. The analysis of game theory scenarios lead into reasoning real-world complex systems in economics, political science, biology, computing, and social structures, primarily dissecting processes of decision making and behavioural relations.","category":"page"},{"location":"introduction/#Agent-based-simulation","page":"Introduction","title":"Agent-based simulation","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Agent-based simulations are a highly important scientific computing task in game theory. While mathematical analysis can provide closed-form or sound theoretical results to problems, developing and running simulations to play out the actions and interactions of autonomous agents in the theoretical of game theory are extremely useful in proving or disproving hypotheses, or revealing new insights into the model and the greater problems of social conflict, dilemmas, and cooperation that the model represents. Agent-based simulations combined with evolutionary processes are highly useful to analyse the outcomes and dynamics of repeated actions and payoffs between agents.","category":"page"},{"location":"introduction/#Scientific-computing-and-the-Julia-language","page":"Introduction","title":"Scientific computing and the Julia language","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The compromises between low-level and high-level programming languages presents a challenge for scientific computing.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Relatively lower-level languages (by modern standards) such as C/C++ provide highly efficient performance, but because their design is oriented towards systems programming they have a strong specificity for low-level or “machine-oriented” operations such as memory allocation that bloats development time and makes them very unsuitable for fast or intuitive prototyping—an attribute very important for scientific computing.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Higher-level languages such as Python have consequently become popular in many areas of modern scientific computing due to a \"friendlier\" approach to readability and automation of low-level operations, but the implementation of being easy and dynamic, mainly through being interpreted—rather than compiled—also produces far less optimal performance. Especially in computing tasks that rely on optimised, repeated operations, such as simulations, the slowness of Python and other popular high-level languages produces magnitudes of inefficiency.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"First appearing in 2012–relatively recent for a programming language–the Julia programming language has emerged as a solution to this rift between ease and performance, providing the high-level dynamic readability of Python, but through sophisticated design decisions such as a just-in-time (JIT) compiler and eager evaluation, it delivers on the optimised performance seen by the likes of C/C++, achieving petaFLOP computations. Julia, as a result, presents new and exciting potential for new works in scientific computing.","category":"page"},{"location":"introduction/#Design-of-the-Jedy-package","page":"Introduction","title":"Design of the Jedy package","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Jedy (name originating from from Julia Evolutionary DYnamics) is a package developed to provide a lightweight framework for building reliable and efficient agent-based simulations in Julia. The primary focus is to provide abstractions that allow for quick, intuitive, and reliable development of agent-based ideas, as well as already implemented and tested functions to run commonly-used evolutionary algorithms such as imitation processes and Wright-Fisher evolution.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"A very important aspect to the development of this package is an understanding of Julia’s design as a language, aiming for Jedy to be idiomatic to the language to fully leverage its strengths.","category":"page"},{"location":"introduction/#Typing","page":"Introduction","title":"Typing","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The type system of a programming language regulates the usage of different data types/structures in a program. Formally, Julia is strongly typed, that is each variable/object must remain the same type in its lifetime (as opposed to weak, like Python, where terms can change type), and dynamically type-checked, that is the validity of this typing is checked at run-time (as opposed to static type-checking, like C++, done at compile time).","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Dynamic type checking allows the types of variables to be “inferred”, such that Julia variables can be defined like such:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"a = 4","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"While convenient, a notable concern is the ambiguity of variable types, especially in the context of parameters of functions where using the correct type may be useful, or different types may require different functions (overloading). To solve this, Julia allows for rich, in-built type hinting. For example:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"function divide(a::Int, b::Int) :: Float64\n    return a/b\nend","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Here it is clear that the divide function will take in two integers, and return a floating point number. ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"For the goal of “reliability” for Jedy, this element of Julia is highly important. Consider: ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"function imitation_process!(agents::Array{Jedy.Agent},\n                            fitnesses::Array{Float64},\n                            w::Float64)\n    # ...\nend","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In this function all the types are clearly set out, including the core custom type of the “Agent.” Also note there is no returning type, thus this function does not return anything, and the Julia convention of this function’s naming using a “!” denotes that it uses in-place operations on the parameter types (i.e. the mutable array of agents can be manipulated).","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The philosophy of clear typing, even when the implicit typing is possible, is the clear Julianic way of a package such as Jedy to promote reliability.","category":"page"},{"location":"introduction/#Composition-over-inheritance","page":"Introduction","title":"Composition over inheritance","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"While object-oriented languages such as Java will greatly favour inheritance. Instead, there aren’t sophisticated objects but rather sophisticated combinations of objects, most ideally implemented functionally (that is, using functions).","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"For Jedy, this means not creating seperate special different types of Agents or encapsulating simulations within an object, but rather focusing on various functions and specifying what types can be given to them. For scientific computing, this approach has a huge advantage on reliability, and at times efficiency when evading overly-clunky object operations, by minimising the complexity of relationships.","category":"page"},{"location":"introduction/#Thorough-documentation","page":"Introduction","title":"Thorough documentation","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Documentation is extremely important to a package’s utility. For Jedy, a modern use of Julia’s Documenter.jl was used to generate a sophisticated static website, hosted here in a conventional documentation structure with an introduction, usage, examples, as well as API documentation generated from Jedy's in-script docstrings with the @autodocs feature. Paired with the use of tagging to clearly version documentation, this makes for a thorough resource to learn and understand Jedy with easy scalibility to future developments.","category":"page"},{"location":"introduction/#Open-sourcing","page":"Introduction","title":"Open-sourcing","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Julia makes a very interesting choice for packages (importable libraries/tools developed for Julia) to naturally be git repositories (contribution/version control directories). As this makes open-sourcing extremely easy, almost every Julia repository is open-source. Jedy is no different, and the source-code is accessible and able to be contributed to here.","category":"page"},{"location":"introduction/#Logging-customisation","page":"Introduction","title":"Logging customisation","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Being able to record intermediate and resulting data is key to scientific computing, so Julia implements as a first-class feature the use of a custom log, with the flexible solution of providing a function that takes in the agents and returns some array that will constitute each line in the outputted CSV.","category":"page"},{"location":"introduction/#Example","page":"Introduction","title":"Example","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The Prisoner's Dilemma is a staple problem in game theory. Two agents must choose to either defect or cooperate with the other, without knowing the others' choice. Defecting when the other cooperates provides the highest reward T and lowest S to the other, but both defecting provides a low reward P, and both cooperating provides a decent reward R such that T > R > P > S. The key insight from analysing behaviour in the prisoner's dilemma is that agents will tend to defect instead of cooperate as the Nash Equilibrium, even though this will result in an overall worse payoff in the end than cooperation. This is of fundamental interest to the study of how unoptimal consequences of cooperation/defection in the real world can occur.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can use Jedy to simulate agents playing the repeated Prisoner's Dilemma with an evolutionary process to see the success of defecting vs. cooperating.","category":"page"},{"location":"introduction/#.-Define-population","page":"Introduction","title":"1. Define population","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"First, let's make a population of 100 agents with a randomly-assigned boolean attribute \"behaviour\" that defines if they defect (true) or cooperate (false):","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"import Jedy\nimport Random\n\nN = 100\nagents = Array{Jedy.Agent}(undef, N)\nfor i in 1:N\n    agents[i] = Jedy.Agent(Dict(\"behaviour\" => rand(Bool)))\nend","category":"page"},{"location":"introduction/#.-Define-way-of-determining-payoffs/fitness","page":"Introduction","title":"2. Define way of determining payoffs/fitness","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We use a straight-forward function for two agents to play the Prisoner's Dilemma:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"function play_prisoners_dilemma(agent_a::Jedy.Agent, agent_b::Jedy.Agent) :: Tuple{Int, Int}\n    T, R, P, S = 3, 2, 1, 0\n    action_a = agent_a.body[\"behaviour\"]\n    action_b = agent_b.body[\"behaviour\"]\n    if action_a && action_b\n        return (P, P)\n    elseif action_a && !action_b\n        return (T, S)\n    elseif !action_a && action_b\n        return (S, T)\n    else\n        return (R, R)\n    end\nend","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can then use this for our compute_fitness function. Here we compute fitness by the total payoff each agent accumulates against 1000 random opponents.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"function compute_fitnesses(agents::Array{Jedy.Agent}) :: Array{Float64}\n    n = length(agents)\n    fitnesses = zeros(n)\n\n    for f in 1:n\n        for _ in 1:100 # Agent[f] plays 100 prisoner's dilemmas\n            r = f\n            while r == f # Pick non-self opponent\n                r = rand(1:n)\n            end\n            payoff_f, payoff_r = play_prisoners_dilemma(agents[f], agents[r])\n            fitnesses[f] += payoff_f\n            fitnesses[r] += payoff_r\n        end\n    end\n    return fitnesses\nend","category":"page"},{"location":"introduction/#.-Define-evolution-process","page":"Introduction","title":"3. Define evolution process","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Let's use an imitation process.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"# Imitation process with w=0.2 (weak selection)\nimitation_process! = Jedy.EvolutionProcesses.create_imitation_process(0.2)","category":"page"},{"location":"introduction/#.-Run-simulation!","page":"Introduction","title":"4. Run simulation!","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Here we do 200 epochs:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Jedy.run_simulation!(agents,\n                     compute_fitnesses,\n                     imitation_process!,\n                     200)","category":"page"},{"location":"introduction/#(Optional)-Logging-to-CSV","page":"Introduction","title":"(Optional) Logging to CSV","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"It's very useful to be able to log values from each epoch's agents. We can add a highly-customisable logger function easily:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"# Logs the behaviour of each agent\nfunction logger(agents::Array{Jedy.Agent})\n    vals = map(a -> a.body[\"behaviour\"], agents)\n    return \"temp.log\", vals\nend\n\n# Run simulation with logger\nJedy.run_simulation!(agents,\n                     compute_fitnesses,\n                     perform_imitation_process!,\n                     200,\n                     logger)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Full code available here.","category":"page"},{"location":"introduction/#Future-work","page":"Introduction","title":"Future work","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The project so far has been on the groundwork and approach of Jedy, but there are many more features and developments that could contribute well to the package in future work. Most prominently:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Implementation of more evolutionary processes.\nDirect visualisation tools (i.e. shorthands for common plots).\nAdvanced debugging (i.e. customisable verification tools).","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"As Jedy is open-source, the progression of new features are clear, and of course open to contributions as a living project.","category":"page"},{"location":"#Jedy.jl","page":"Home","title":"Jedy.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for developing agent-based simulations & evolutionary dynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jedy provides fundamental tooling to work with agents and evolutionary algorithms, making use of Julia's speed and ease-of-development.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Introduction for an in-depth explanation to Jedy's motivation and approach.\nSee Examples for examples of using Jedy.\nSee API for complete documentation on Jedy's functions/types/etc.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Open the Julia REPL in your terminal with julia, type ] to enter the Pkg mode, and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/lucrae/Jedy.jl.git","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simply import Jedy and use the functions/types in the API. For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Jedy\n\na = Jedy.Agent(\"behaviour\" => 1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Latest release:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Version) (Image: Docs)  (Image: Tests) (Image: Documentation)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Open-sourced on GitHub.","category":"page"}]
}
